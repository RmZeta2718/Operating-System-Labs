# Project 0a: Linux Warm Up

10185102223 汪杰



## Part 1

### s1.sh

```shell
#!/bin/bash
mkdir foo
cd foo
echo WangJie > name.txt
echo 10185102223 > stno.txt
cp name.txt namecp.txt
cp stno.txt stnocp.txt
```

第一行指明该脚本将会用bash这个程序运行。

- mkdir 接收一个参数，在当前目录下创建一个以参数为名的目录文件。
- cd 接收一个目录文件的地址作为参数，并进入该目录。
- echo输出字符串，通过重定向，将字符串输出到指定文件。
- cp src dst ，拷贝文件src到dst。



### s2.sh

```
#!/bin/bash
find /bin/ -name "b*" -type f | sort | xargs ls -l | awk '{sub(/\/bin\//, "", $9); print $9, $3, $1}' > output
chmod o=r output
```

- find 在指定目录下寻找文件，并输出对应的文件名。
  - -name选项指定文件名的格式，“b*”是一个正则表达式，表示开头包含一个字母b，随后跟上任意字符串。
  - -type选项指定文件类型，f表示文件类型为普通文件
- sort接收一系列字符串，并将其按字典序排序。这里通过管道接收find输出的文件名，并排序。
- xargs执行某个特定命令，并将输入的字符串作为参数，加到命令之后。通过管道接收sort传来的文件名，相当于对每个文件名name执行ls -l name
  - ls显示当前目录下的文件，-l 表示显示完整内容，再指定一个文件名name表示只输出该文件的完整内容。
  - 到这里将会输出bin目录下，以b开头的普通文件的完整信息。每行代表一个文件，每列代表某个文件的一个属性。
- awk以行为单元处理，按空格分隔参数并存入寄存器中。
  - 文件名带有路径，首先通过awk中的sub函数，匹配路径并替换为空字符串，即删除路径。
  - 然后取出需要的三列：文件名（第9列），拥有者（第3列），访问权限（第1列），按照规定的顺序打印。
- 最后重定向输出到文件output。
- 最后通过chmod 更改访问权限。
  - o=r表示others的访问权限为read，即只读。
  - 第二个参数为文件名

上述方案中，

- 寻找文件和删除文件路径（/bin/）的操作比较复杂，应该有更优雅的方式。时间和精力所限，没法做得更好。
- find输出的结果似乎已经按字典序排序，所以sort或许可以去掉。（保险起见没有去掉）



## Part 2

编译命令为

```shell
gcc set_operation.c -o set_operation
```

-o指定可执行文件的文件名。

下面罗列所有bug。行号参考修正后的set_operation.c，即提交的文件。

- 修正一个编译错误。37行：->->改为->
- 37行代码逻辑错误，if(p->next->number==num)应当为if(p->number==num)
- 检查输入是否正确：76-78行，直接输出链表A，结果正确。
- 链表B的输入和A的输入代码几乎一致，保险起见，在100-102行输出了链表B，结果正确，与预期一致。
- 接着出现了段错误，错误位置时110行，i<=A_size;应当改为i<A_size;
- 125-127行输出A2，结果正确。
- 又出现段错误。检查计算A-B的代码逻辑，发现133行与注释不符，且正确的代码逻辑与注释相同。所以!check改为check，去掉感叹号
- 160行有相同的错误，去掉感叹号



## Bonus 1

```shell
#!/bin/bash
awk 'BEGIN {FS = "\n"; a=1} {if (a == 10) print $0; a += 1}'
```

awk读取行，用变量a计数，满足a为10则打印。

FS是字段分隔符，默认为空格，为了打印整行，这里将其改为换行符，这样整行都是字段0。

BEGIN后的语句是在循环读入每行之前执行的，在此处修改FS和初始化a。

